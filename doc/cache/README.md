<!-- MarkdownTOC levels="1,2,3,4,5,6" autolink="true"  style="unordered" -->

- [Redis](#redis)
	- [原理](#%E5%8E%9F%E7%90%86)
	- [数据结构](#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
	- [内存淘汰机制](#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6)
	- [过期键的删除策略](#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5)
	- [集群部署方式](#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F)
	- [主从复制原理和优化策略](#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5)
	- [持久化原理](#%E6%8C%81%E4%B9%85%E5%8C%96%E5%8E%9F%E7%90%86)
- [缓存](#%E7%BC%93%E5%AD%98)
	- [缓存和数据库双写一致性问题](#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98)
	- [缓存雪崩问题](#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98)
	- [缓存击穿问题](#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98)
	- [缓存的并发竞争问题](#%E7%BC%93%E5%AD%98%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98)

<!-- /MarkdownTOC -->

## Redis
#### 原理
#### 数据结构
#### 内存淘汰机制
#### 过期键的删除策略
#### 集群部署方式
#### 主从复制原理和优化策略
#### 持久化原理


## 缓存
#### 缓存和数据库双写一致性问题
#### 缓存雪崩问题
缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常

缓存雪崩解决方案：  
- 给缓存的失效时间，加上一个随机值，避免集体失效。
- 使用互斥锁，但是该方案吞吐量明显下降了。
- 双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。
- 然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。

#### 缓存击穿问题
缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
缓存穿透解决方案：
- 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
- 采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
- 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。

#### 缓存的并发竞争问题
